package org.nosco;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.sql.DataSource;

/**
 * This class contains is used to start, commit and roll back transactions when using this API. &nbsp;
 * Transactions are specific to both the {@code DataSource} and the current thread. &nbsp;  Typical use
 * would be like the following (where {@code db.DEFAULT} is the data source generated by the {@code CodeGenerator}):
 * <pre>   {@code TransactionThread.start(db.DEFAULT);
 *   SomeClass x = SomeClass.ALL.get(SomeClass.ID.eq(123));
 *   x.setName("my new name");
 *   x.update();
 *   doSomeOtherWork();
 *   SomeClass.ALL.where(SomeClass.ID.eq(456)).deleteAll();
 *   TransactionThread.commit(db.DEFAULT);}</pre>
 * If any of the SQL calls failed (throwing a {@code SQLException}), the transaction would be rolled back. &nbsp;
 * Note that database calls in {@code doSomeOtherWork()} will also be within this transaction (as long as they're
 * still within the same thread).
 * 
 * 
 * @author Derek Anderson
 */
public class TransactionThread {
	
	static ConcurrentHashMap<DataSource,ThreadLocal<Connection>> tls = new ConcurrentHashMap<DataSource,ThreadLocal<Connection>>();
	
	/**
	 * Returns true if currently inside a transaction.
	 * @param ds
	 * @return
	 */
	public static boolean inTransaction(DataSource ds) {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return false;
		return tl.get() != null;
	}
	
	/**
	 * Starts a new transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean start(DataSource ds) throws SQLException {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) {
			ThreadLocal<Connection> tmp = tls.put(ds, tl);
			if (tmp != null) tl = tmp;
		}
		Connection c = tl.get();
		if (c != null) return false;
		c = ds.getConnection();
		c.setAutoCommit(false);
		tl.set(c);
		return true;
	}
	
	/**
	 * Commits the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean commit(DataSource ds) throws SQLException {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return false;
		Connection c = tl.get();
		if (c == null) return false;
		c.commit();
		return true;
	}
	
	/**
	 * Rolls back the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean rollback(DataSource ds) throws SQLException {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return false;
		tls.remove(ds);
		Connection c = tl.get();
		if (c == null) return false;
		c.rollback();
		return true;
	}
	
	/**
	 * Gets the connection for this transaction.
	 * @param ds
	 * @return null is not currently in a transaction
	 */
	public static Connection getConnection(DataSource ds) {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return null;
		return tl.get();
	}
	
}
