package org.nosco;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

/**
 * This class is used to control thread-based context operations. &nbsp; For instance
 * you can
 * start, commit and roll back transactions using this API. &nbsp;
 * All operations are specific to both the {@code DataSource} and the current thread. &nbsp;
 * Typical use
 * would be like the following (where {@code db.DEFAULT} is the data source generated by
 * the {@code CodeGenerator} or pulled from a {@code Query} instance):
 * <pre>   {@code ThreadContext.start(db.DEFAULT);
 *   SomeClass x = SomeClass.ALL.get(SomeClass.ID.eq(123));
 *   x.setName("my new name");
 *   x.update();
 *   doSomeOtherWork();
 *   SomeClass.ALL.where(SomeClass.ID.eq(456)).deleteAll();
 *   ThreadContext.commit(db.DEFAULT);}</pre>
 * If any of the SQL calls failed (throwing a {@code SQLException}), the transaction would
 * be rolled back. &nbsp;
 * Note that database calls in {@code doSomeOtherWork()} will also be within this
 * transaction (as long as they're still within the same thread).
 *
 * @author Derek Anderson
 * @deprecated please use Context.getThreadContext()
 */
public class ThreadContext {

	private long connectionCount = 0;

	private ThreadContext() {}

	private static ThreadLocal<ThreadContext> tl = new ThreadLocal<ThreadContext>() {
		@Override
		protected ThreadContext initialValue() {
			return new ThreadContext();
		}
	};

	/**
	 * Returns true if currently inside a transaction.
	 * @param ds
	 * @return
	 * @deprecated please use Context.inTransaction(ds);
	 */
	public static boolean inTransaction(DataSource ds) {
		return Context.inTransaction(ds);
	}

	/**
	 * Starts a new transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 * @deprecated please use Context.getThreadContext().startTransaction(ds);
	 */
	public static boolean startTransaction(DataSource ds) throws SQLException {
		return Context.getThreadContext().startTransaction(ds);
	}

	/**
	 * Commits the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 * @deprecated please use Context.getThreadContext().commitTransaction(ds);
	 */
	public static boolean commitTransaction(DataSource ds) throws SQLException {
		return Context.getThreadContext().commitTransaction(ds);
	}

	/**
	 * Rolls back the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 * @deprecated please use Context.getThreadContext().rollbackTransactionThrowSQLException(ds);
	 */
	public static boolean rollbackTransaction(DataSource ds) throws SQLException {
		return Context.getThreadContext().rollbackTransactionThrowSQLException(ds);
	}

	/**
	 * Rolls back the current transaction, ignoring any {@code SQLException}s thrown.
	 * &nbsp; This is a convenience method for use in finally blocks, where you feel
	 * there isn't anything you can do about it anyway.
	 * @param ds
	 * @return
	 * @throws SQLException
	 * @deprecated please use Context.getThreadContext().rollbackTransaction(ds);
	 */
	public static boolean rollbackTransactionIgnoreException(DataSource ds) {
		return Context.getThreadContext().rollbackTransaction(ds);
	}

	/**
	 * Gets the connection for this transaction.
	 * @param ds
	 * @return null is not currently in a transaction
	 * @deprecated please use Context.getConnection(ds);
	 */
	public static Connection getConnection(DataSource ds) {
		return Context.getConnection(ds);
	}

	/**
	 * Gets number of connections for this thread.
	 */
	public static long getConnectionCount() {
		ThreadContext tc = tl.get();
		return tc.connectionCount;
	}

	/**
	 * Increments the number of connections for this thread.
	 */
	static long incrementConnectionCount() {
		ThreadContext tc = tl.get();
		return ++tc.connectionCount;
	}

	/**
	 * Sets the number of connections for this thread. &nbsp;
	 * It makes sense to set this when you want to use incremental measuring. &nbsp;
	 * For instance, in a test case, you can set to 0, then confirm only n connections
	 * were made. (where each connection is another SQL query)
	 *
	 */
	public static void setConnectionCount(long count) {
		ThreadContext tc = tl.get();
		tc.connectionCount = count;
	}

	/**
	 * All extracted schemas contain the database names they're extracted from. &nbsp;
	 * Setting this will cause all access to {@code mydatabase.my_table} to
	 * {@code myotherdatabase.my_table}. &nbsp;
	 * (applied on a per-thread basis) &nbsp;
	 * Note that in this context database means the database instance, not the database server.
	 * @param ds
	 * @param oldName
	 * @param newName
	 * @deprecated please use {@code Context.getThreadContext().overrideSchema(ds, oldName, newName)}
	 */
	public static void setDatabaseOverride(DataSource ds, String oldName, String newName) {
		Context.getThreadContext().overrideSchema(ds, oldName, newName);
	}

	/**
	 * All extracted schemas contain the database names they're extracted from. &nbsp;
	 * This will look up any name overrides set with  {@code setDatabaseOverride()},
	 * returning the original name is no overrides have been set.&nbsp;
	 * Note that in this context database means the database instance, not the database server.
	 * @param ds
	 * @param name
	 * @return
	 * @deprecated please use {@code Context.getSchemaToUse(ds, name)}
	 */
	public static String getDatabaseOverride(DataSource ds, String name) {
		return Context.getSchemaToUse(ds, name);
	}

}
