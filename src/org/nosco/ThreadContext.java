package org.nosco;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.sql.DataSource;

/**
 * This class is used to control thread-based context operations. &nbsp; For instance
 * you can
 * start, commit and roll back transactions using this API. &nbsp;
 * All operations are specific to both the {@code DataSource} and the current thread. &nbsp;
 * Typical use
 * would be like the following (where {@code db.DEFAULT} is the data source generated by
 * the {@code CodeGenerator} or pulled from a {@code Query} instance):
 * <pre>   {@code ThreadContext.start(db.DEFAULT);
 *   SomeClass x = SomeClass.ALL.get(SomeClass.ID.eq(123));
 *   x.setName("my new name");
 *   x.update();
 *   doSomeOtherWork();
 *   SomeClass.ALL.where(SomeClass.ID.eq(456)).deleteAll();
 *   ThreadContext.commit(db.DEFAULT);}</pre>
 * If any of the SQL calls failed (throwing a {@code SQLException}), the transaction would
 * be rolled back. &nbsp;
 * Note that database calls in {@code doSomeOtherWork()} will also be within this
 * transaction (as long as they're still within the same thread).
 *
 * @author Derek Anderson
 */
public class ThreadContext {

	private static ConcurrentHashMap<DataSource,ThreadLocal<Connection>> tls =
			new ConcurrentHashMap<DataSource,ThreadLocal<Connection>>();
	private static ConcurrentHashMap<DataSource,ThreadLocal<Map<String,String>>> schemaOverrides =
			new ConcurrentHashMap<DataSource,ThreadLocal<Map<String,String>>>();

	/**
	 * Returns true if currently inside a transaction.
	 * @param ds
	 * @return
	 */
	public static boolean inTransaction(DataSource ds) {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return false;
		return tl.get() != null;
	}

	/**
	 * Starts a new transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean startTransaction(DataSource ds) throws SQLException {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) {
			ThreadLocal<Connection> tmp = tls.put(ds, tl);
			if (tmp != null) tl = tmp;
		}
		Connection c = tl.get();
		if (c != null) return false;
		c = ds.getConnection();
		c.setAutoCommit(false);
		tl.set(c);
		return true;
	}

	/**
	 * Commits the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean commitTransaction(DataSource ds) throws SQLException {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return false;
		Connection c = tl.get();
		if (c == null) return false;
		c.commit();
		return true;
	}

	/**
	 * Rolls back the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean rollbackTransaction(DataSource ds) throws SQLException {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return false;
		tls.remove(ds);
		Connection c = tl.get();
		if (c == null) return false;
		c.rollback();
		return true;
	}

	/**
	 * Gets the connection for this transaction.
	 * @param ds
	 * @return null is not currently in a transaction
	 */
	public static Connection getConnection(DataSource ds) {
		ThreadLocal<Connection> tl = tls.get(ds);
		if (tl == null) return null;
		return tl.get();
	}

	/**
	 * All extracted schemas contain the database names they're extracted from. &nbsp;
	 * Setting this will cause all access to {@code mydatabase.my_table} to
	 * {@code myotherdatabase.my_table}. &nbsp;
	 * (applied on a per-thread basis) &nbsp;
	 * Note that in this context database means the database instance, not the database server.
	 * @param ds
	 * @param oldName
	 * @param newName
	 */
	public static void setDatabaseOverride(DataSource ds, String oldName, String newName) {
		ThreadLocal<Map<String, String>> tl = schemaOverrides.get(ds);
		if (tl == null) {
			ThreadLocal<Map<String, String>> tmp = schemaOverrides.put(ds, tl);
			if (tmp != null) tl = tmp;
		}
		Map<String, String> overrides = tl.get();
		if (overrides == null) tl.set(overrides = new HashMap<String,String>());
		overrides.put(oldName, newName);
	}

	/**
	 * All extracted schemas contain the database names they're extracted from. &nbsp;
	 * This will look up any name overrides set with  {@code setDatabaseOverride()},
	 * returning the original name is no overrides have been set.&nbsp;
	 * Note that in this context database means the database instance, not the database server.
	 * @param ds
	 * @param name
	 * @return
	 */
	public static String getDatabaseOverride(DataSource ds, String name) {
		ThreadLocal<Map<String, String>> tl = schemaOverrides.get(ds);
		if (tl == null) return name;
		Map<String, String> overrides = tl.get();
		if (overrides == null) return name;
		String newName = overrides.get(name);
		if (newName == null) return name;
		return newName;
	}

}
