package org.nosco;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

/**
 * This class is used to control thread-based context operations. &nbsp; For instance
 * you can
 * start, commit and roll back transactions using this API. &nbsp;
 * All operations are specific to both the {@code DataSource} and the current thread. &nbsp;
 * Typical use
 * would be like the following (where {@code db.DEFAULT} is the data source generated by
 * the {@code CodeGenerator} or pulled from a {@code Query} instance):
 * <pre>   {@code ThreadContext.start(db.DEFAULT);
 *   SomeClass x = SomeClass.ALL.get(SomeClass.ID.eq(123));
 *   x.setName("my new name");
 *   x.update();
 *   doSomeOtherWork();
 *   SomeClass.ALL.where(SomeClass.ID.eq(456)).deleteAll();
 *   ThreadContext.commit(db.DEFAULT);}</pre>
 * If any of the SQL calls failed (throwing a {@code SQLException}), the transaction would
 * be rolled back. &nbsp;
 * Note that database calls in {@code doSomeOtherWork()} will also be within this
 * transaction (as long as they're still within the same thread).
 *
 * @author Derek Anderson
 */
public class ThreadContext {

	// these hashmaps don't need to be synchronized/thread-safe, since they're
	// only ever being called by one thread thanks to being in a ThreadLocal.
	private Map<DataSource,Map<String,String>> schemaOverrides =
			new HashMap<DataSource,Map<String,String>>();
	private Map<DataSource,Connection> transactionConnections =
			new HashMap<DataSource,Connection>();

	private ThreadContext() {}

	private static ThreadLocal<ThreadContext> tl = new ThreadLocal<ThreadContext>() {
		@Override
		protected ThreadContext initialValue() {
			return new ThreadContext();
		}
	};

	/**
	 * Returns true if currently inside a transaction.
	 * @param ds
	 * @return
	 */
	public static boolean inTransaction(DataSource ds) {
		ThreadContext tc = tl.get();
		return tc.transactionConnections.containsKey(ds);
	}

	/**
	 * Starts a new transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean startTransaction(DataSource ds) throws SQLException {
		ThreadContext tc = tl.get();
		Connection c = tc.transactionConnections.get(ds);
		if (c != null) return false;
		c = ds.getConnection();
		c.setAutoCommit(false);
		tc.transactionConnections.put(ds, c);
		return true;
	}

	/**
	 * Commits the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean commitTransaction(DataSource ds) throws SQLException {
		ThreadContext tc = tl.get();
		Connection c = tc.transactionConnections.get(ds);
		if (c == null) return false;
		c.commit();
		c.close();
		return true;
	}

	/**
	 * Rolls back the current transaction.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean rollbackTransaction(DataSource ds) throws SQLException {
		ThreadContext tc = tl.get();
		Connection c = tc.transactionConnections.get(ds);
		tc.transactionConnections.remove(ds);
		if (c == null) return false;
		c.rollback();
		c.close();
		return true;
	}

	/**
	 * Rolls back the current transaction, ignoring any {@code SQLException}s thrown.
	 * &nbsp; This is a convenience method for use in finally blocks, where you feel
	 * there isn't anything you can do about it anyway.
	 * @param ds
	 * @return
	 * @throws SQLException
	 */
	public static boolean rollbackTransactionIgnoreException(DataSource ds) {
		ThreadContext tc = tl.get();
		Connection c = tc.transactionConnections.get(ds);
		tc.transactionConnections.remove(ds);
		if (c == null) return false;
		try {
			c.rollback();
			c.close();
			return true;
		} catch (SQLException e) {
			e.printStackTrace();
			try {
				c.close();
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
			return false;
		}
	}

	/**
	 * Gets the connection for this transaction.
	 * @param ds
	 * @return null is not currently in a transaction
	 */
	public static Connection getConnection(DataSource ds) {
		ThreadContext tc = tl.get();
		Connection c = tc.transactionConnections.get(ds);
		return c;
	}

	/**
	 * All extracted schemas contain the database names they're extracted from. &nbsp;
	 * Setting this will cause all access to {@code mydatabase.my_table} to
	 * {@code myotherdatabase.my_table}. &nbsp;
	 * (applied on a per-thread basis) &nbsp;
	 * Note that in this context database means the database instance, not the database server.
	 * @param ds
	 * @param oldName
	 * @param newName
	 */
	public static void setDatabaseOverride(DataSource ds, String oldName, String newName) {
		ThreadContext tc = tl.get();
		Map<String, String> overrides = tc.schemaOverrides.get(ds);
		if (overrides == null) {
			overrides = new HashMap<String,String>();
			tc.schemaOverrides.put(ds, overrides);
		}
		overrides.put(oldName, newName);
	}

	/**
	 * All extracted schemas contain the database names they're extracted from. &nbsp;
	 * This will look up any name overrides set with  {@code setDatabaseOverride()},
	 * returning the original name is no overrides have been set.&nbsp;
	 * Note that in this context database means the database instance, not the database server.
	 * @param ds
	 * @param name
	 * @return
	 */
	public static String getDatabaseOverride(DataSource ds, String name) {
		ThreadContext tc = tl.get();
		Map<String, String> overrides = tc.schemaOverrides.get(ds);
		if (overrides == null) return name;
		String newName = overrides.get(name);
		if (newName == null) return name;
		return newName;
	}

}
