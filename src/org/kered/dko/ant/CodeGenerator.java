package org.kered.dko.ant;

import java.io.File;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;

public class CodeGenerator extends Task {
	
	CodeGeneratorBase base = new CodeGeneratorBase();

	/**
	 * Path to the jar file that should be generated.
	 * @param s
	 */
	public void setJarfile(final String s) {
		base.setJarfile(s);
	}

	/**
	 * Optional path to the jar file that should be generated containing only source code.
	 * @param s
	 */
	public void setSrcJarfile(final String s) {
		base.setSrcJarfile(s);
	}
	
	/**
	 * Optional set of space-separated prefixes to strip from table names.
	 * @param s
	 */
	public void setStripPrefixes(final String s) {
		base.setStripPrefixes(s);
	}
	
	/**
	 * The output directory for the generated java classes.
	 * @param s
	 */
	public void setJavaOutputDir(final String s) {
		base.setJavaOutputDir(s);
	}

	/**
	 * Whether to enable debugging in the generated code.
	 * @param s
	 */
	public void setDebug(final String s) {
		base.setDebug(s);
	}

	/**
	 * The base path of the generated classes.  For instance, with a base path of "org.kered.myapp",
	 * a schema called "mydb" and a table "my_table", the generated class would be {@code org.kered.myapp.mydb.MyTable}.
	 * @param s
	 */
	public void setPackage(final String s) {
		base.setPackage(s);
	}
	
	public void setAllConstType(final String s) {
		base.setAllConstType(s);
	}

	public void setAllConstFactory(final String s) {
		base.setAllConstFactory(s);
	}

	/**
	 * The classpath to use when compiling the genned code
	 * @param s
	 */
	public void setClasspath(final String s) {
		base.setClasspath(s);
	}

	/**
	 * Defines the default datasource for for all generated classes.  This should look like a Java assignment
	 * operation that calls some code of yours that returns a datasource.  For instance: {@code myDb = MyDataSourceFactory.getDataSource();} <br>
	 * @param s
	 */
	public void setDataSource(final String s) {
		base.setDataSource(s);
	}

	/**
	 * The path to the JSON file (generated with {@link org.kered.dko.ant.SchemaExtractorBase}) containing your database schema.
	 * @param s
	 */
	public void setSchemas(final String s) {
		base.setSchemas(s);
	}

	/**
	 * By default generated DKO {@code toString()} methods call {@code toStringSimple()}
	 * (which display columns in the primary key plus any fields named like "*name*").
	 * If instead you'd like it to default to calling {@code toStringDetailed()} (which
	 * returns all fetched fields), set this to true.
	 * @param s
	 */
	public void setUseDetailedToString(final String s) {
		base.setUseDetailedToString(s);
	}

//	public void setGson(final String s) {
//		this.genGson  = Util.truthy(s);
//	}
//
	/**
	 * By default, DKOs use the schema name as the package name.  If you want to specify
	 * your own package name, do so here.  Format is comma separated with "as"... like so:
	 * "schema1 as pkg1, schema2 as pkg2, schema3 as pkg3"
	 * @param s
	 */
	public void setAliases(final String s) {
		base.setSchemaAliases(s);
	}

	/**
	 * Path to the optional enums JSON file (which would be generated by {@link org.kered.dko.ant.SchemaExtractorBase}).
	 * @param s
	 */
	public void setEnums(final String s) {
		base.setEnums(s);
	}

	/**
	 * Path to an optional user-written JSON that controls what default types should map to what
	 * custom java types and how to convert those types.  For instance, SQL timestamp columns by default
	 * map to {@code java.sql.Timestamp} classes.  If instead you'd prefer {@code java.util.Date}s:
	 *
	 * <pre>{
	 *     "class_mappings": {
	 *         "java.sql.Timestamp": "java.util.Date",
	 *     },
	 *     "functions": {
	 *       "java.sql.Timestamp java.util.Date" :
	 *           "new java.util.Date((%s).getTime()",
	 *       "java.util.Date java.sql.Timestamp" :
	 *           "new java.sql.Timestamp((%s).getTime()",
	 *     }
	 * }</pre>
	 *
	 * Note the "functions" section where you can provide code that converts from one to another.
	 * <p>
	 * If you don't want all types to be mapped the same way for all classes, you can specify Java
	 * regex statements (matched against the schema/table/column names) to specify certain classes.
	 * For example, this will do the same as the previous example, but only for fields with names ending in "_date":
	 *
	 * <pre>{
	 *     "schema_mappings": {
	 *         ".*_date": "java.util.Date",
	 *     },
	 *     "functions": {
	 *       "java.sql.Timestamp java.util.Date" :
	 *           "new java.util.Date((%s).getTime()",
	 *       "java.util.Date java.sql.Timestamp" :
	 *           "new java.sql.Timestamp((%s).getTime()",
	 *     }
	 * }</pre>
	 *
	 * @param s
	 */
	public void setTypeMappings(final String s) {
		base.setTypeMappings(s);
	}

	/**
	 * Sets the path to your javac binary.
	 * @param s
	 */
	public void setJavac(final String s) {
		base.setJavac(s);
	}

	/**
	 * Sets the Javac target Java version for the compiled code.
	 * @param s
	 */
	public void setJavacTarget(final String s) {
		base.setJavacTarget(s);
	}

	/**
	 * Sets the Javac source parameter.
	 * @param s
	 */
	public void setJavacSource(final String s) {
		base.setJavacSource(s);
	}

	/**
	 * Usually DKOs use the automatically generated FK relationships extracted from the database.  But sometimes
	 * those foreign keys aren't actually there.  (usually for performance reasons)  Specifying this file lets
	 * you add FK relationships to the generated code regardless.  The format is JSON like the following:
	 *
	 * <pre>{
	 *     "fk_1":{
	 *         "reffing": ["my_schema","product"],
	 *         "reffed": ["my_schema","manufacturer"],
	 *         "columns": {"manufacturer_id": "id"}
	 *     },
	 * }</pre>
	 *
	 * This will create a FK relationship from {@code product.manufacturer_id} to {@code manufacturer.id}.
	 * Compound keys are simply additional entries in the "columns" map.
	 *
	 * @param s
	 */
	public void setFakeFKs(final String s) {
		base.setFakeFks(s);
	}

	/**
	 * DKOs support a variety of callbacks pre and post database operations.  Specify this parameter for
	 * where the generated DKOs should look.  For instance, a schema/table {@code myapp.product} could
	 * generate a class {@code org.kered.myapp.Product}.  Which if given a callback package of
	 * "org.kered.myapp.callbacks" would look for callback methods in {@code org.kered.myapp.callbacks.ProductCB}.
	 *
	 * @param s
	 */
	public void setCallbackPackage(final String s) {
		base.setCallbackPackage(s);
	}

	@Override
	public void execute() {
		try {
			base.execute();
		} catch (RuntimeException e) {
			throw new BuildException(e);
		}
	}

}
