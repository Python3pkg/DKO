<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" [
  <!ENTITY test1jva SYSTEM "../../gen/docbook/test1.jva">
  <!ENTITY test1out SYSTEM "../../gen/docbook/test1.out">
  <!ENTITY test2jva SYSTEM "../../gen/docbook/test2.jva">
  <!ENTITY test2out SYSTEM "../../gen/docbook/test2.out">
  <!ENTITY test3jva SYSTEM "../../gen/docbook/test3.jva">
  <!ENTITY test3out SYSTEM "../../gen/docbook/test3.out">
  <!ENTITY test4jva SYSTEM "../../gen/docbook/test4.jva">
  <!ENTITY test4out SYSTEM "../../gen/docbook/test4.out">
  <!ENTITY test5jva SYSTEM "../../gen/docbook/test5.jva">
  <!ENTITY test5out SYSTEM "../../gen/docbook/test5.out">
  <!ENTITY test6jva SYSTEM "../../gen/docbook/test6.jva">
  <!ENTITY test6out SYSTEM "../../gen/docbook/test6.out">
  <!ENTITY test7jva SYSTEM "../../gen/docbook/test7.jva">
  <!ENTITY test7out SYSTEM "../../gen/docbook/test7.out">
  <!ENTITY test8jva SYSTEM "../../gen/docbook/test8.jva">
  <!ENTITY test8out SYSTEM "../../gen/docbook/test8.out">
  <!ENTITY test9jva SYSTEM "../../gen/docbook/test9.jva">
  <!ENTITY test9out SYSTEM "../../gen/docbook/test9.out">
  <!ENTITY test10jva SYSTEM "../../gen/docbook/test10.jva">
  <!ENTITY test10out SYSTEM "../../gen/docbook/test10.out">
  <!ENTITY test11jva SYSTEM "../../gen/docbook/test11.jva">
  <!ENTITY test11out SYSTEM "../../gen/docbook/test11.out">
  <!ENTITY test12jva SYSTEM "../../gen/docbook/test12.jva">
  <!ENTITY test12out SYSTEM "../../gen/docbook/test12.out">
  <!ENTITY test13jva SYSTEM "../../gen/docbook/test13.jva">
  <!ENTITY test13out SYSTEM "../../gen/docbook/test13.out">
  <!ENTITY test14jva SYSTEM "../../gen/docbook/test14.jva">
  <!ENTITY test14out SYSTEM "../../gen/docbook/test14.out">
  <!ENTITY test15jva SYSTEM "../../gen/docbook/test15.jva">
  <!ENTITY test15out SYSTEM "../../gen/docbook/test15.out">
  <!ENTITY test16jva SYSTEM "../../gen/docbook/test16.jva">
  <!ENTITY test16out SYSTEM "../../gen/docbook/test16.out">
  <!ENTITY test17jva SYSTEM "../../gen/docbook/test17.jva">
  <!ENTITY test17out SYSTEM "../../gen/docbook/test17.out">
  <!ENTITY test18jva SYSTEM "../../gen/docbook/test18.jva">
  <!ENTITY test18out SYSTEM "../../gen/docbook/test18.out">
  <!ENTITY test19jva SYSTEM "../../gen/docbook/test19.jva">
  <!ENTITY test19out SYSTEM "../../gen/docbook/test19.out">
  <!ENTITY test20jva SYSTEM "../../gen/docbook/test20.jva">
  <!ENTITY test20out SYSTEM "../../gen/docbook/test20.out">
  <!ENTITY test21jva SYSTEM "../../gen/docbook/test21.jva">
  <!ENTITY test21out SYSTEM "../../gen/docbook/test21.out">
  <!ENTITY test22jva SYSTEM "../../gen/docbook/test22.jva">
  <!ENTITY test22out SYSTEM "../../gen/docbook/test22.out">
  <!ENTITY test23jva SYSTEM "../../gen/docbook/test23.jva">
  <!ENTITY test23out SYSTEM "../../gen/docbook/test23.out">
  <!ENTITY test24jva SYSTEM "../../gen/docbook/test24.jva">
  <!ENTITY test24out SYSTEM "../../gen/docbook/test24.out">
  <!ENTITY test25jva SYSTEM "../../gen/docbook/test25.jva">
  <!ENTITY test25out SYSTEM "../../gen/docbook/test25.out">
  <!ENTITY test26jva SYSTEM "../../gen/docbook/test26.jva">
  <!ENTITY test26out SYSTEM "../../gen/docbook/test26.out">
  <!ENTITY test27jva SYSTEM "../../gen/docbook/test27.jva">
  <!ENTITY test27out SYSTEM "../../gen/docbook/test27.out">
  <!ENTITY test28jva SYSTEM "../../gen/docbook/test28.jva">
  <!ENTITY test28out SYSTEM "../../gen/docbook/test28.out">
  <!ENTITY test29jva SYSTEM "../../gen/docbook/test29.jva">
  <!ENTITY test29out SYSTEM "../../gen/docbook/test29.out">
]>

<book>
  <title>DKOs - The Book</title>
  
  <chapter>
    <title>Introduction</title>
    <section>
      <title>Should You Read This?</title>
      <para>TODO: STUB</para>
      <para>target audience</para>
    </section>
    <section>
      <title>Problems with Traditional ORMs</title>
      <para>TODO: STUB</para>
      <para>string concat == bad</para>
      <para>leads to db code isolation</para>
      <para>"isolated" code grows to be large part of your project</para>
      <para>or people use getAll() methods</para>
      <para>always select * from...</para>
      <para>xml configuration nightmare</para>
      <para>live objects are bad</para>
    </section>
    <section>
      <title>Principles Behind DKOs</title>
      <para>TODO: STUB</para>
      <para>embrace sql</para>
      <para>all compile-time checked</para>
      <para>ORM mappings always 1-to-1</para>
    </section>
    <section>
      <title>Precursors to DKOs</title>
      <para>TODO: STUB</para>
      <para>django query api</para>
      <para>apache torque</para>
    </section>
  </chapter>  

  <chapter>
    <title>Setting Up DKOs</title>
    <section>
      <title>Overview</title>
      <para>TODO: STUB</para>
      <para>ant-only</para>
    </section>
    <section>
      <title>Extracting Your Database Schema</title>
      <para>TODO: STUB</para>
      <para>enums.json</para>
    </section>
    <section>
      <title>Generating Classes</title>
      <para>TODO: STUB</para>
      <para>type_mappings.json</para>
      <para>fake_fks.json</para>
      <para>default datasource</para>
      <para>callbacks</para>
      <para>code generation overview</para>
    </section>
  </chapter>

  <chapter>
    <title>Table Models</title>
    <section>
      <title>Overview</title>
      <para>Table classes serve two purposes in DKOs.  First they model the database table itself.  And second they model the rows in the table.  This may seem odd at first.  Why would we not use two different classes to model the table and the row?  (In fact this is done in every other ORM I've seen)  But I think this adds unnecessary complexity to the framework when you consider that tables and their rows are in reality so closely intertwined as to be nearly inseparable.  And when you consider than another method of bifurcating is available:  The "static" modifier.</para>
      <para>In a generated table class (by convention) everything that is a static method or variable is applicable to the database table, where everything that is not static applies to the row.  Let's take a look at an example:</para>
      <programlisting language="java"><![CDATA[public class Person extends Table {

	public static final Query<Person> ALL = [...];

	public static final Field<Integer> ID = [...];
	public static final Field<String>  FIRST_NAME = [...];
	public static final Field<String>  LAST_NAME = [...];
	public static final Field<Date>    BIRTH_DATE = [...];
	public static final Field<String>  SSN = [...];

	public Integer getId() {}
	public String getFirstName() {}
	public String getLastName() {}
	public Date getBirthDate() {}
	public java.lang.String getSsn() {}

}]]></programlisting>
      <para>You can clearly see the columns of the table are all static constants (useful for building database queries), where an instance of the class Person would have getter methods for the values in a specific row.</para>
      <para></para>
      <programlisting language="java"><![CDATA[]]></programlisting>
      <para></para>
    </section>
    <section>
      <title>Fields</title>
      <para>Fields represent database columns.  All table classes have at least one public static field instance.  They are immutable and contain basic information about the database column they reflect (such as their type in SQL, their type in Java, the column name, what table they're a part of, etc.)  You will likely never construct one but they are one of the most important parts of the DKO library.  This is because fields are how you construct conditionals.  For instance, let's assume the following SQL query:</para>
      <programlisting language="sql"><![CDATA[select * from PERSON where FIRST_NAME='Derek';]]></programlisting>
      <para>The where clause of this query is a simple equality condition.  To create a DKO representation of this condition you would use the following:</para>
      <programlisting language="sql"><![CDATA[Condition condition = Person.FIRST_NAME.eq("Derek");]]></programlisting>
      <para>This condition object could then be passed into the where method on a query.  For Example:</para>
      <programlisting language="sql"><![CDATA[Query<Person> q = Person.ALL.where(condition);]]></programlisting>
      <para>Of course this is such a small example you would probably do it all on one line:</para>
      <programlisting language="sql"><![CDATA[Query<Person> q = Person.ALL.where(Person.FIRST_NAME.eq("Derek"));]]></programlisting>
      <para>All normal SQL conditional statements have direct corollaries in DKO.  Here is a table of SQL to field method names:</para>
      <table>
      	<title>Field Methods vs. SQL Comparisons</title>
      	<tgroup cols='3' align='left' colsep='2' rowsep='1'>
          <thead>
            <row>
              <entry>Operation</entry>
              <entry>SQL</entry>
              <entry>Field Method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Equal to</entry>
              <entry>field = x</entry>
              <entry>FIELD.eq(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Greater than</entry>
              <entry>field &gt; x</entry>
              <entry>FIELD.gt(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Less than</entry>
              <entry>field &lt; x</entry>
              <entry>FIELD.lt(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Greater than or equal to</entry>
              <entry>field &gt;= x</entry>
              <entry>FIELD.gte(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Less than or equal to</entry>
              <entry>field &lt;= x</entry>
              <entry>FIELD.lte(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Not equal to</entry>
              <entry>field &lt;&gt; x</entry>
              <entry>FIELD.neq(<emphasis>x</emphasis>)</entry>
            </row>
            <!--row>
              <entry>And</entry>
              <entry>field1=x and field2=y</entry>
              <entry>FIELD1.eq(<emphasis>x</emphasis>).and(FIELD2.eq(<emphasis>y</emphasis>))</entry>
            </row>
            <row>
              <entry>Or</entry>
              <entry>field1=x or field2=y</entry>
              <entry>FIELD1.eq(<emphasis>x</emphasis>).or(FIELD2.eq(<emphasis>y</emphasis>))</entry>
            </row-->
            <row>
              <entry>Between</entry>
              <entry>field between x and y</entry>
              <entry>FIELD.between(<emphasis>x</emphasis>, <emphasis>y</emphasis>)</entry>
            </row>
          </tbody>
		</tgroup>
      </table>
      <para>Math operations are also supported:</para>
      <table>
      	<title>Field Methods vs. SQL Math Operations</title>
      	<tgroup cols='3' align='left' colsep='2' rowsep='1'>
          <thead>
            <row>
              <entry>Operation</entry>
              <entry>SQL</entry>
              <entry>Field Method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Addition</entry>
              <entry>field + x</entry>
              <entry>FIELD.add(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Subtraction</entry>
              <entry>field - x</entry>
              <entry>FIELD.sub(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Multiplication</entry>
              <entry>field * x</entry>
              <entry>FIELD.mul(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Division</entry>
              <entry>field / x</entry>
              <entry>FIELD.div(<emphasis>x</emphasis>)</entry>
            </row>
            <row>
              <entry>Modulus</entry>
              <entry>field % x</entry>
              <entry>FIELD.mod(<emphasis>x</emphasis>)</entry>
            </row>
          </tbody>
		</tgroup>
      </table>
      <para>All of these field operations are not limited to constants of their type (such as Field&lt;String>.eq(String)).  They all also take other fields of compatible types (ie: Field&lt;String>.eq(Field&lt;String>)) or SQL function objects (which we'll discuss later).</para>
      <para>All generated table classes also have a "public static List&lt;Field&lt;?>> _FIELDS" object that is an immutable list of all fields in the table.</para>
      <para></para>
      <para></para>
    </section>
    <section>
      <title>Instances</title>
      <para>Instances of classes that extend Table represent the rows in that table.  For example, if I wanted to create a new row in the person table in our example schema, I would do something like this:</para>
      <programlisting language="java"><![CDATA[Person person = new Person();
person.setFirstName("Derek");
person.setLastName("Anderson");
boolean success = person.insert();]]></programlisting>
      <para>Since all generated table objects follow a builder pattern, this would also be valid:</para>
      <programlisting language="java"><![CDATA[boolean success = new Person()
	.setFirstName("Derek")
	.setLastName("Anderson")
	.insert();]]></programlisting>
      <para>Both of these statements would insert into the default DataSource defined when generating these classes.  If none provided, you would need to provide one when calling insert.  (This is also how you would change at run-time which database the insert went to, assuming you have multiple databases)</para>
      <programlisting language="java"><![CDATA[DataSource ds = getSomeDataSource();
boolean success = new Person()
	.setFirstName("Derek")
	.setLastName("Anderson")
	.insert(ds);]]></programlisting>
      <para>Since our example is hitting a SQLite3 database and this table has a auto-generated primary key "id", we can access the value by subsequently calling "person.getId()".</para>
      <para>All of your normal database operations are available:</para>
      <table>
      	<title>Table Instance SQL Methods</title>
      	<tgroup cols='3' align='left' colsep='2' rowsep='1'>
          <thead>
            <row>
              <entry>SQL Operation</entry>
              <entry>Instance Method</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>INSERT</entry>
              <entry>person.insert();</entry>
              <entry>Inserts the given row into the database.  All fields that have been set are inserted.  (None of the fields that haven't been set are, allowing for database defaults)  Throws a SQLException if the row already exists.</entry>
            </row>
            <row>
              <entry>UPDATE</entry>
              <entry>person.update();</entry>
              <entry>Updates the row in the database.  (Throws a SQLException if it doesn't exist)  Only the fields that have changed are updated (ie: it doesn't clobber any other fields that might have changed in the database in the interim)</entry>
            </row>
            <row>
              <entry>DELETE</entry>
              <entry>person.delete();</entry>
              <entry>Deletes the row in the database.  Throws a SQLException if it doesn't exist.</entry>
            </row>
            <row>
              <entry>EXISTS</entry>
              <entry>person.exists();</entry>
              <entry>Returns true if this row already exists in the database.  If the table has a primary key defined, this is used for the check.  Otherwise all columns are used.</entry>
            </row>
            <row>
              <entry>INSERT or UPDATE</entry>
              <entry>person.save();</entry>
              <entry>Automatically performs an insert or an update based on whether this row exists in the database already.</entry>
            </row>
          </tbody>
		</tgroup>
      </table>
      <para>All of the above methods also have versions that take a specific DataSource.</para>
      <para>All generated Table classes also have a generic "public &lt;T> get(Field&lt;T>)" method that will return the value associated with a given field.  Also they all have a "public List&lt;Field&lt;?>> fields()" that returns all the fields set or fetched for this specific instance.</para>
      <para></para>
    </section>
    <section>
      <title>Foreign Keys</title>
      <para>Foreign key relationships are a critical part of any database design and are automatically extracted and modeled in DKO-generated classes.  Let's look at our example schema:</para>
      <mediaobject id="example_schema">
        <imageobject>
          <imagedata fileref="db.png"/>
        </imageobject>
      </mediaobject>
      <para>Now let's look at the code generated for the appointment table:</para>
      <programlisting language="java"><![CDATA[public class Appointment extends Table {

	public static final Query<Appointment> ALL = [...];

	public static final Field<Integer> ID = [...];
	public static final Field<Integer> PATIENT_ID = [...];
	public static final Field<Integer> DOCTOR_ID = [...];
	public static final Field<Integer> OFFICE_ID = [...];
	public static final Field<Date>    START = [...];
	public static final Field<Date>    END = [...];
	
	public static final Field.FK<Patient> FK_PATIENT = [...];
	public static final Field.FK<Doctor>  FK_DOCTOR = [...];
	public static final Field.FK<Office>  FK_OFFICE = [...];

	public Integer getId() {}
	public Integer getPatientId() {}
	public Integer getDoctorId() {}
	public Integer getOfficeId() {}
	public Date    getStart() {}
	public Date    getEnd() {}

	public Patient getPatientIdFK() {}
	public Doctor  getDoctorIdFK() {}
	public Office  getOfficeIdFK() {}
	
}]]></programlisting>
      <para>You should recognize the static Field objects, but you'll also notice the static Field.FK objects.  These obviously represent the foreign key relationships extracted from the database.</para>
      <para>You'll also note that for every foreign key defined, a "get*FK()" method is also created.  If you call "getDoctorId()" you will receive the integer value in the column.  But if you call "getDoctorIdFK()" you will receive a full-fledged Doctor object (itself containing all the values in a row of the doctor table).</para>
      <para>If you're at the other end of the relationship you can still traverse the foreign key.  For example, look at this subset of the generated office class:</para>
      <programlisting language="java"><![CDATA[public class Office extends Table {

	public static final Query<Office> ALL = [...];

	public static final Field<Integer> ID = [...];
	public static final Field<String> ADDRESS1 = [...];
	// etc
	
	public Query<Doctor>      getDoctorSet() {}
	public Query<Appointment> getAppointmentSet() {}
	
}]]></programlisting>
      <para>Two methods are added to let you retrieve the set of all doctors (or appointments) that reference this office instance.  These methods return full-fledged query objects that can be filtered or joined with other tables as needed.  (or simply turned into a list with "asList()")</para>
      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Queries</title>
    <section>
      <title>Overview</title>
      <para>DKO Query objects are the primary entry point for almost all uses of DKO objects.  It's name is somewhat misleading because the Query interface covers not just SQL select statements but all normal CRUD operations.  Combining both read and write operations into one interface was done intentionally however, as they are also intricately linked in SQL.  (recall that one of the goals of DKO is to embrace SQL, not hide it)  And naming it a "Query" intentionally reflects the almost universal disproportionate weighting of reads over writes in most programming applications.</para>
      <para>There are two important aspects of DKO queries I want to make special note of here:</para>
      <para>The first is that queries are immutable.  They follow a builder pattern, but at every step they return a new object.  This allows you to mix and match queries in different sections of code without worry.  It's very common to save off a commonly used query somewhere and have multiple other sections of your application further refine it with additional conditionals, joins, etc.</para>
      <para>The second is that they are all implementers of java.lang.Iterable.  This means they can be used in the new Java for-each loops, which is by far the most common way to access the rows in a table.  It also means that's it's easy to run a query more often than you intended.  Every time Query.iterator() is called a new connection to the database is made.  (recall that Iterables can be iterated over multiple times, where Iterators can only be iterated over once)  It is very difficult (some would say impossible) to write good "should I cache this?" code without making performance (and run-time results) unpredictable.  When designing DKOs I intentionally left caching up to the discretion of the programmer.  (And attempted to make it dead-simple, such as with the "Query.asList()" method)</para>
    </section>
    <section>
      <title>Hello World</title>
      <para>Given our example schema and generated code defined so far, let's look at some simple examples.  For instance, printing out all the people in our database:</para>
      <programlisting language="java">&test1jva;</programlisting>
      <para>Will print the following:</para>
      <programlisting language="java">&test1out;</programlisting>
      <para>Take a look at the static constant "Person.ALL".  This is of type Query&lt;Person>, which is of type Iterable&lt;Person> (which is why you can use it in a for-each loop).  When iterated over it runs the query (basically a "select *") and streams the results from the database into your loop.  All generated DKO objects have this special (immutable) query object and it serves as the root source of all access to the person table in our database.</para>
      <para>Note the line starting with "==>":  This is debug information (optionally) printed to stderr whenever the DKO library runs a query against the database.  For all of the examples in this book I will include these lines to help demonstrate when the DKO library is hitting the database and when it is not.</para>
      <para>The default toString() method of a DKO object is the class name, the primary key of the table and any "important" fields.  Here "important" is defined by a heuristic that may change as the DKO library evolves, but currently is simply whether the field name contains the strings "name" or "title".  If you want all the fields of a DKO object there is a similar toStringDetailed() method on each class.</para>
    </section>
    <section>
      <title>Conditions</title>
      <para>Only rarely are "select *" queries (such as in the Hello World example) useful.  Most SQL queries contain a "where clause".  Likewise, most DKO queries also contain a where clause.  Let's look at an example.  Suppose you want to find all the people with the first name "Derek".</para>
      <programlisting language="sql"><![CDATA[select * from person where first_name='Derek']]></programlisting>
      <para>The equivalent DKO query would be:</para>
      <programlisting language="java"><![CDATA[Query<Person> q = Person.ALL.where(Person.FIRST_NAME.eq("Derek"));]]></programlisting>
      <para>This API was intentionally written to have as much of a SQL "feel" as possible.  Let's break this down by type to better understand what's going on.</para>
      <programlisting language="java"><![CDATA[Field<String> fn = Person.FIRST_NAME;
Condition whereClause = fn.eq("Derek");
Query<Person> q = Person.ALL.where(whereClause);]]></programlisting>
      <para>Condition objects can be combined with "and" or "or":</para>
      <programlisting language="java"><![CDATA[Query<Person> q = Person.ALL.where(
    Person.FIRST_NAME.eq("Derek").and(Person.LAST_NAME.eq("Anderson"))
);]]></programlisting>
      <para>Many queries are easier to read if you use static imports for the fields:</para>
      <programlisting language="java"><![CDATA[import static Person.*;
Query<Person> q = Person.ALL.where(
    FIRST_NAME.eq("Derek").and(LAST_NAME.eq("Anderson"))
);]]></programlisting>
      <para>Going forward many of my code samples will assume a static import of the fields exists.</para>
      <para>Note: Field objects are generic, so a Field&lt;String> only has a .eq(String) method, not .eq(Object).</para>
      <para>Conditions have the following methods available:</para>
      <table>
      	<title>Condition Methods vs. SQL Conditions</title>
      	<tgroup cols='2' align='left' colsep='2' rowsep='1'>
          <thead>
            <row>
              <entry>SQL</entry>
              <entry>Condition Method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>where <emphasis>a</emphasis> and <emphasis>b</emphasis></entry>
              <entry><emphasis>a</emphasis>.and(<emphasis>b</emphasis>)</entry>
            </row>
            <row>
              <entry>where <emphasis>a</emphasis> or <emphasis>b</emphasis></entry>
              <entry><emphasis>a</emphasis>.or(<emphasis>b</emphasis>)</entry>
            </row>
            <row>
              <entry>where not <emphasis>a</emphasis></entry>
              <entry><emphasis>a</emphasis>.not()</entry>
            </row>
          </tbody>
    	  </tgroup>
      </table>
    </section>
    <section>
      <title>The With Method</title>
      <para>The method Query.with(Field.FK...) is how you perform the majority of joins in DKOs.  Let's look at our schema again for reference:</para>
      <mediaobject id="example_schema2">
        <imageobject>
          <imagedata fileref="db.png"/>
        </imageobject>
      </mediaobject>
      <section>
        <title>Many to One Joins</title>
      <para>In our schema an appointment is made up of a patient, a doctor and an office.  Let's look at an example:</para>
      <programlisting language="java">&test2jva;</programlisting>
      <para>Will print the following:</para>
      <programlisting language="java">&test2out;</programlisting>
      <para>This is an example of lazy-loading.  Two queries are run.  The first fetches the doctor instance.  The second fetches the office instance when it is needed.  This is useful behavior, but it can cause performance problems if done repeatedly.  To speed up this code we need to join the doctor and office tables and retrieve both in one go.  To do this we use Query.with(Field.FK...).  Here is the same code performing that join:</para>
      <programlisting language="java">&test3jva;</programlisting>
      <para>Prints out the following:</para>
      <programlisting language="java">&test3out;</programlisting>
      <para>Notice only one query is run (with the appropriate join) and the returned doctor object's FK method is already linked to the related office object.</para>
      <para>Often you want to join more than one table.  What if you want to print a list of all upcoming appointments?</para>
      <programlisting language="java">&test4jva;</programlisting>
      <para>When run prints out the following:</para>
      <programlisting language="java">&test4out;</programlisting>
      <para>Notice that all four tables are joined together automatically, and that the returned object is a composite of the corresponding four table objects.</para>
      <para>You may have also noticed that the with method takes a vararg.  (ie: Field.FK...)  Passing multiple FK references into one with statement lets you travel multiple levels deep into the object graph.  For instance, if you wanted to include the doctor's primary office in the previous example you would do the following:</para>
      <programlisting language="java">&test5jva;</programlisting>
      <para>When run prints out the following:</para>
      <programlisting language="java">&test5out;</programlisting>
      <para>Tables joined with the "with()" method can be used in where clauses as well.  For instance, what if we wanted to only print appointments where the appointment office and the primary office of the doctor are different?</para>
      <programlisting language="java">&test6jva;</programlisting>
      <para>When run prints out the following:</para>
      <programlisting language="java">&test6out;</programlisting>
      </section>
      <section>
        <title>One to Many Joins</title>
        <para>So far all of our examples have "many to one" joins.  What if you want a "one to many" join?  For instance what if you want all the appointments for a given doctor?  Every object that is the target of a foreign key has a ".getFKSet()" method which returns all the objects with a foreign key to this object.  Let's look at an example:</para>
      <programlisting language="java">&test7jva;</programlisting>
      <para>When run prints out the following:</para>
      <programlisting language="java">&test7out;</programlisting>
        <para>Oops!  Well, this did get all the appointments for a doctor in the one query, but we lazy-loaded the patient information.  Let's pull that in with the appointment:</para>
      <programlisting language="java">&test8jva;</programlisting>
      <para>Which prints out the following:</para>
      <programlisting language="java">&test8out;</programlisting>
      <para>As you can see we now are fetching all three tables in one query.</para>
      <para>A closer look at the API will reveal that the ".getAppointmentSet()" method doesn't return a java.util.Set.  It returns a Query&lt;Appointment> which (in this case) is backed by a in-memory query implementation.  It's entirely possible to further filter your returned results even after your original database query is made.</para>
      </section>
    </section>
    <section>
      <title>Aggregation Functions</title>
      <para>Many common database aggregation features are first-class citizens of the DKO library.  Here are some of the most commonly used.</para>
      <section>
        <title>Query.count()</title>
        <para>Performs a count of the rows in your query.  For example:</para>
        <programlisting language="java">&test9jva;</programlisting>
        <programlisting language="java">&test9out;</programlisting>
      </section>
      <section>
        <title>Query.countBy(Field)</title>
        <para>Performs a count of the rows in your query grouped by a given field.  For example:</para>
        <programlisting language="java">&test10jva;</programlisting>
        <programlisting language="java">&test10out;</programlisting>
      </section>
      <section>
        <title>Query.mapBy(Field)</title>
        <para>Creates an in-memory map of the value of the given field to the object.  For example:</para>
        <programlisting language="java">&test11jva;</programlisting>
        <programlisting language="java">&test11out;</programlisting>
      </section>
      <section>
        <title>Query.collectBy(Field)</title>
        <para>You'll notice in the previous example only one object can be returned for each field value.  Because there are two patients with the last name "Anderson", there is a race and only one will be returned.  (which one is determined by the order the database returns the rows in)  If we want to capture both objects we can use the collectBy() method.  For example:</para>
        <programlisting language="java">&test12jva;</programlisting>
        <programlisting language="java">&test12out;</programlisting>
      </section>
      <section>
        <title>Query.sum(Field)</title>
        <para>If you want to sum a given field, use Query.sum(Field).  For example:</para>
        <programlisting language="java">&test13jva;</programlisting>
        <programlisting language="java">&test13out;</programlisting>
      </section>
      <section>
        <title>Query.sumBy(Field, Field)</title>
        <para>If you want to sum a given field grouped by another field, use Query.sum(Field1, Field2).  For example:</para>
        <programlisting language="java">&test14jva;</programlisting>
        <programlisting language="java">&test14out;</programlisting>
      </section>
      <section>
        <title>Query.average(Field)</title>
        <para>If you want to average a given field, use Query.average(Field).  For example:</para>
        <programlisting language="java">&test15jva;</programlisting>
        <programlisting language="java">&test15out;</programlisting>
      </section>
      <section>
        <title>Query.averageBy(Field, Field)</title>
        <para>If you want to average a given field grouped by another field, use Query.averageBy(Field1, Field2).  For example:</para>
        <programlisting language="java">&test16jva;</programlisting>
        <programlisting language="java">&test16out;</programlisting>
      </section>
    </section>
    <section>
      <title>Terminal vs. Non-terminal Methods</title>
      <para>When is a query run?</para>
      <para>The short and sweet of it is it's run when a terminal method is called.  A terminal method is a method that does not return a Query object.  For example, Query.sum(Field) is a terminal method because it returns a double.  Query.onlyFields(Field) is not because it returns another Query (which can be further specified).</para>
      <para>TODO: Table of terminal vs. non-terminal methods</para>
    </section>
    <section>
      <title>Order By</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Distinct</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Limit Operations</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Selecting Only Specific Fields</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Performance</title>
      <para>DKOs are streaming where-ever possible.  Assuming your JDBC driver isn't terribly written you can iterate over huge datasets that would be impossible to fit into memory.  (And we do - few companies have larger data sets than my employer)</para>
      <para>Comparisons to Hibernate are tricky.  When optimized, Hibernate is every bit as fast as DKOs.  (both are barely distinguishable from pure JDBC)  But when you factor in the time it takes to optimize Hibernate queries vs. DKO queries (and the fact that developer hours are limited), anecdotal evidence (a known mixed environment of Hibernate and DKOs) suggests that DKOs average runtimes less than half of comparable Hibernate queries.  (and with substantially less code)</para>
      <section>
        <title>Automatic Query Optimizations</title>
        <para>TODO</para>
      </section>
      <section>
        <title>Automatic Performance Warnings</title>
        <para>TODO</para>
      </section>
    </section>
    <section>
      <title>Inner Queries</title>
      <para>Previously we looked at an example for calculating cost averages by item types sold:</para>
      <programlisting language="java">&test16jva;</programlisting>
      <programlisting language="java">&test16out;</programlisting>
      <para>This works, but is inefficient because it pulls from the database more items than it needs.  This is fine in this example but could be a huge bottleneck if you have millions of available products for sale.  A better implementation would use an inner query.  For example:</para>
      <programlisting language="java">&test17jva;</programlisting>
      <programlisting language="java">&test17out;</programlisting>
      <para>In SQL, queries used as inner queries can only return one column.  To select which column we use the ".onlyFields()" method you see in the example above.</para>
      <para></para>
      <para></para>
    </section>
    <section>
      <title>Temporary Tables</title>
      <para>The method Field.in() can take more than just an inner query.  Like in SQL it can take an arbitrary collection.  For instance:</para>
      <programlisting language="java">&test18jva;</programlisting>
      <programlisting language="java">&test18out;</programlisting>
      <para>This could also be written like:</para>
      <programlisting language="java">&test19jva;</programlisting>
      <programlisting language="java">&test19out;</programlisting>
      <para>You'll note at the end of the SQL statement that DKOs use Java PreparedStatements (exclusively).  The two question marks are placeholders for the values shown pipe-delimited at the end of the query.  The DKO library is designed to way to protect you from SQL-injection attacks.</para>
      <para>This technique of multiple placeholder values doesn't scale well however.  So after a current threshold (currently 256) DKOs switch to a temporary table and an inner query.  This is transparent to you but provides a significant performance boost (esp. on SQL Server).</para>
    </section>
    <section>
      <title>Table Aliases</title>
      <para>Sometimes you need to join a table to itself or you for some other reason have the same table in your query multiple times.  We saw an example of this before when comparing the appointment office location with the primary office location of the appointment's doctor.  Let's look at that again:</para>
      <programlisting language="java">&test6jva;</programlisting>
      <programlisting language="java">&test6out;</programlisting>
      <para>In this instance the fields were not ambiguous and the comparison operation was symmetric, so the DKO library simply assigned one field to one table and the other field to the other.  But sometimes it's not clear-cut like this and you need to specify which field is from which table (just like you do in SQL).  To do this you use the Table.as() and Field.from() methods.  For an (admittedly contrived) example selecting only patients with family members who are also patients:</para>
      <programlisting language="java">&test20jva;</programlisting>
      <programlisting language="java">&test20out;</programlisting>
      <para></para>
      <para></para>
      <para></para>
      <para></para>
    </section>
    <section>
      <title>SQL Functions</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Joins</title>
      <para>TODO</para>
    </section>
    <section>
      <title>as*() Transformations</title>
      <para>TODO</para>
    </section>
  </chapter>
  <chapter>
    <title>Write Operations</title>
    <section>
      <title>Insert</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Update</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Delete</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Transactions</title>
      <para>DKOs support transactions.  (They would be of little use if they didn't!)  But first we must introduce Context objects.  Let's first look at some example code:</para>
      <programlisting language="java">&test21jva;</programlisting>
      <programlisting language="java">&test21out;</programlisting>
      <para>The first thing we do here is get a reference to the javax.sql.DataSource configured as the default for our Patient.ALL query.  All query objects have this getDataSource() method.  We need this because transactions are handled per-datasource.</para>
      <para>The next thing we do is get a reference to our context.  For this example we're using the VM context which means that transactions we start here will apply to all future queries (in all threads) that use this datasource (until we commit or it back).</para>
      <para>The third thing we do it start a transaction on the given datasource.  Internally the DKO library keeps the connection open and reuses it for all future queries until the transaction is committed or rolled back.  The method context.startTransaction() returns a boolean value indicating success.</para>
      <para>The rest of the example should be familiar to you by now, until you context.rollbackTransaction().</para>
      <para></para>
      <para></para>
      <para></para>
    </section>
  </chapter>
  <chapter>
    <title>Data Sources</title>
      <para></para>
    <section>
      <title>MatryoshkaDataSource</title>
      <para>TODO</para>
    </section>
    <section>
      <title>ConnectionCountingDataSource</title>
      <para>TODO</para>
    </section>
    <section>
      <title>MirroredDataSource</title>
      <para>TODO</para>
    </section>
    <section>
      <title>ReflectedDataSource</title>
      <para>TODO</para>
    </section>
    <section>
      <title>SingleConnectionDataSource</title>
      <para>TODO</para>
    </section>
    <section>
      <title>SingleThreadedDataSource</title>
      <para>TODO</para>
    </section>
    <section>
      <title>UnclosableConnection</title>
      <para>TODO</para>
    </section>
  </chapter>
  <chapter>
    <title>Miscellaneous</title>
    <section>
      <title>Contexts</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Bulk Operations</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Supported Databases</title>
      <para>TODO</para>
    </section>
    <section>
      <title>Diffs</title>
      <para>TODO</para>
    </section>
    <section>
      <title>CSV</title>
      <para>TODO</para>
    </section>
    <section>
      <title>FAQs</title>
      <para>Q: What happens when I call .where() multiple times on the same query object?</para>
      <para>A: All the calls to .where() are "and"ed together.</para>
      <para>Q: I've called .onlyFields() but now I want to either update or delete.  Is this safe?</para>
      <para>A: Yes.  Write operations will ignore calls to .onlyFields() or .deferFields().</para>
      <para>Q: </para>
      <para>A: </para>
      <para>Q: </para>
      <para>A: </para>
      <para>Q: </para>
      <para>A: </para>
    </section>
  </chapter>

</book> 
